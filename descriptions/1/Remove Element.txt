Учитывая целочисленный массив nums и целочисленное val, удалите все вхождения val в nums на месте. Порядок элементов может быть изменен. Затем верните количество элементов в nums, которые не равны val.

Рассмотрим количество элементов в nums, которые не равны val be k, чтобы вас приняли, вам нужно сделать следующее:

Измените массив nums так, чтобы первые k элементов nums содержали элементы, не равные val. Остальные элементы nums не важны, как и размер nums.
Вернуться к.
Пользовательский судья:

Судья проверит ваше решение с помощью следующего кода:

int[] числа = [...]; // Входной массив
интервал = ...; // Значение для удаления
int[] ожидаемые числа = [...]; // Ожидаемый ответ правильной длины.
                             // Он отсортирован без значений, равных val.

int k = removeElement (числа, значения); // Вызывает вашу реализацию

утверждать k == ожидаемоеNums.length;
сортировать (числа, 0, к); // Сортируем первые k элементов nums
for (int я = 0; я <фактическая длина; я ++) {
     утверждать nums[i] == ожидаемоеNums[i];
}
Если все утверждения пройдены, ваше решение будет принято.

 

Пример 1:
    Ввод: числа = [3,2,2,3], знач = 3
    Вывод: 2, числа = [2,2,_,_]
    Объяснение: Ваша функция должна возвращать k = 2, причем первые два элемента nums равны 2.
    Неважно, что вы оставляете за возвращенным k (следовательно, это символы подчеркивания).

Пример 2:
    Ввод: числа = [0,1,2,2,3,0,4,2], знач = 2
    Выход: 5, числа = [0,1,4,0,3,_,_,_]
    Объяснение: Ваша функция должна возвращать k = 5, причем первые пять элементов nums содержат 0, 0, 1, 3 и 4.
    Обратите внимание, что пять элементов могут быть возвращены в любом порядке.
    Неважно, что вы оставляете за возвращенным k (следовательно, это символы подчеркивания).

 

Ограничения:

0 <= nums.length <= 100
0 <= число[i] <= 50
0 <= значение <= 100