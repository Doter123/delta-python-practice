Учитывая целочисленный массив nums, отсортированный в неубывающем порядке, удалите дубликаты на месте, чтобы каждый уникальный элемент появлялся только один раз. Относительный порядок элементов должен быть сохранен. Затем верните количество уникальных элементов в nums.

Считайте, что количество уникальных элементов nums равно k, чтобы вас приняли, вам нужно сделать следующее:

Измените массив nums так, чтобы первые k элементов nums содержали уникальные элементы в том порядке, в котором они изначально присутствовали в nums. Остальные элементы nums не важны, как и размер nums.
Вернуться к.
Пользовательский судья:

Судья проверит ваше решение с помощью следующего кода:

int[] числа = [...]; // Входной массив
int[] ожидаемые числа = [...]; // Ожидаемый ответ правильной длины

int k = удалить дубликаты (числа); // Вызывает вашу реализацию

утверждать k == ожидаемоеNums.length;
for (int i = 0; i < k; i++) {
     утверждать nums[i] == ожидаемоеNums[i];
}
Если все утверждения пройдены, ваше решение будет принято.

 

Пример 1:
     Ввод: числа = [1,1,2]
     Вывод: 2, числа = [1,2,_]
     Объяснение: Ваша функция должна возвращать k = 2, причем первые два элемента nums равны 1 и 2 соответственно.
     Неважно, что вы оставляете за возвращенным k (следовательно, это символы подчеркивания).

Пример 2:
     Ввод: числа = [0,0,1,1,1,2,2,3,3,4]
     Выход: 5, числа = [0,1,2,3,4,_,_,_,_,_]
     Объяснение: Ваша функция должна возвращать k = 5, причем первые пять элементов nums равны 0, 1, 2, 3 и 4 соответственно.
     Неважно, что вы оставляете за возвращенным k (следовательно, это символы подчеркивания).

 

Ограничения:

1 <= nums.length <= 3 * 104
-100 <= число[i] <= 100
nums сортируется в порядке неубывания.